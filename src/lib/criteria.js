// Generated by CoffeeScript 1.7.1
'use strict';
var Criteria, Utils, arrayCheck, cmpCheck, logicCheck, numberCheck, regexCheck, stringCheck,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Utils = require('./utils');

numberCheck = function(obj, numberConditon) {
  if (Utils.isNumber(obj) && obj === numberConditon) {
    return true;
  }
  if (Utils.isArray(obj) && (__indexOf.call(obj, numberConditon) >= 0)) {
    return true;
  }
  return false;
};

stringCheck = function(obj, stringCondition) {
  if (Utils.isString(obj) && obj === stringCondition) {
    return true;
  }
  if (Utils.isArray(obj) && (__indexOf.call(obj, stringCondition) >= 0)) {
    return true;
  }
  return false;
};

regexCheck = function(obj, regexCondition) {
  var o, _i, _len;
  if (Utils.isString(obj) && regexCondition.test(obj)) {
    return true;
  }
  if (Utils.isArray(obj)) {
    for (_i = 0, _len = obj.length; _i < _len; _i++) {
      o = obj[_i];
      if (regexCondition.test(o)) {
        return true;
      }
    }
  }
  return false;
};

logicCheck = function(data, key, condition) {
  var c, k, v, _i, _j, _len, _len1;
  for (k in condition) {
    v = condition[k];
    if (k === "$not") {
      if (Criteria.check(data, new function() {
        return this[key] = v;
      })) {
        return false;
      } else {
        return true;
      }
    }
  }
  switch (key) {
    case "$and":
      for (_i = 0, _len = condition.length; _i < _len; _i++) {
        c = condition[_i];
        if (!Criteria.check(data, c)) {
          return false;
        }
      }
      break;
    case "$nor":
      for (_j = 0, _len1 = condition.length; _j < _len1; _j++) {
        c = condition[_j];
        if (Criteria.check(data, c)) {
          return false;
        }
      }
      break;
    case "$or":
      if (!(function() {
        var _k, _len2;
        for (_k = 0, _len2 = condition.length; _k < _len2; _k++) {
          c = condition[_k];
          if (Criteria.check(data, c)) {
            return true;
          }
        }
      })()) {
        return false;
      }
      break;
    default:
      return void 0;
  }
  return true;
};

arrayCheck = function(obj, arrayKey, arrayCondition) {
  var c, _i, _len;
  switch (arrayKey) {
    case "$all":
      if (!Utils.isArray(obj)) {
        return false;
      }
      for (_i = 0, _len = arrayCondition.length; _i < _len; _i++) {
        c = arrayCondition[_i];
        if (!(function() {
          var d, _j, _len1;
          for (_j = 0, _len1 = obj.length; _j < _len1; _j++) {
            d = obj[_j];
            if (Utils.isArray(c) ? arrayCheck(d, arrayKey, c) : d === c) {
              return true;
            }
          }
        })()) {
          return false;
        }
      }
      break;
    case "$elemMatch":
      if (!Utils.isArray(obj)) {
        return false;
      }
      if (!(function() {
        var d, _j, _len1;
        for (_j = 0, _len1 = obj.length; _j < _len1; _j++) {
          d = obj[_j];
          if (Criteria.check(d, arrayCondition)) {
            return true;
          }
        }
      })()) {
        return false;
      }
      break;
    case "$size":
      if (!Utils.isArray(obj)) {
        return false;
      }
      if (obj.length !== arrayCondition) {
        return false;
      }
      break;
    default:
      return void 0;
  }
  return true;
};

cmpCheck = function(obj, key, cmpCondition) {
  var c_key, c_v, c_value, flag, _i, _len, _ref;
  for (c_key in cmpCondition) {
    c_value = cmpCondition[c_key];
    switch (c_key) {
      case "$gt":
        if (obj[key] <= c_value) {
          return false;
        }
        break;
      case "$gte":
        if (obj[key] < c_value) {
          return false;
        }
        break;
      case "$lt":
        if (obj[key] >= c_value) {
          return false;
        }
        break;
      case "$lte":
        if (obj[key] > c_value) {
          return false;
        }
        break;
      case "$ne":
        if (obj[key] === c_value) {
          return false;
        }
        break;
      case "$in":
        flag = true;
        for (_i = 0, _len = c_value.length; _i < _len; _i++) {
          c_v = c_value[_i];
          if (Utils.isRegex(c_v) && c_v.test(obj[key])) {
            flag = false;
            break;
          } else if (obj[key] === c_v) {
            flag = false;
            break;
          }
        }
        if (flag) {
          return false;
        }
        break;
      case "$nin":
        if (_ref = obj[key], __indexOf.call(c_value, _ref) >= 0) {
          return false;
        }
        break;
      case "$exists":
        if (c_value !== (obj[key] != null)) {
          return false;
        }
        break;
      case "$type":
        if (!Utils.isType(obj[key], c_value)) {
          return false;
        }
        break;
      case "$mod":
        if (obj[key] % c_value[0] !== c_value[1]) {
          return false;
        }
        break;
      case "$regex":
        if (!(new RegExp(c_value)).test(obj[key])) {
          return false;
        }
        break;
      default:
        if (!Criteria.check(obj[key], JSON.parse("{\"" + c_key + "\": " + (JSON.stringify(c_value)) + "}"))) {
          return false;
        }
    }
  }
  return true;
};

Criteria = {};

Criteria.check = function(data, criteria) {
  var arrayCheckResult, condition, key, logicCheckResult;
  for (key in criteria) {
    condition = criteria[key];

    /* Number Check
     *  criteria: {a: 1}
     *  data: [{a: 1, b: 2, c: 3}] or [{a:[1,2,3]}]
     */
    if (Utils.isNumber(condition) && key !== "$size") {
      if (numberCheck(data[key], condition)) {
        continue;
      } else {
        return false;
      }
    }

    /* String Check
     *  criteria: {a: "abc"}
     *  data: [{a: "abc", b: 2, c: 3}] or [{a: ["abc","bcd","edf"], b: 2, c: 3}]
     */
    if (Utils.isString(condition)) {
      if (stringCheck(data[key], condition)) {
        continue;
      } else {
        return false;
      }
    }

    /* Regex Check
     *  criteria: {a: /abc+/}
     *  data: [{a: "abcabc"}] or [{a: ["abcabc", "aaa", "bbb"]}]
     */
    if (Utils.isRegex(condition)) {
      if (regexCheck(data[key], condition)) {
        continue;
      } else {
        return false;
      }
    }

    /* Logic Check
     *  $and criteria: {$and: [{a: 1}, {b: 2}]}
     *  data: [{a:1, b:2, c:3}]
     *  $or criteria: {$or: [{a: 1}, {b: 2}]}
     *  data: [{a:1, b:3, c:4}] or [{a:2, b:2, c:3}]
     *  $nor criteria: {$nor: [{a: 1}, {b: 2}]}
     *  data: [{a:2, b:3, c:4}]
     *  TODO $not criteria: {a: {$not: {$gt: 10}}} //a is field
     *  data: [{a:5, b:3, c:4}] 
     *  TO DISCUSS : Should we add feature to support {$not: {a: 10}} kind of criteria?
     */
    logicCheckResult = logicCheck(data, key, condition);
    if (logicCheckResult != null) {
      if (logicCheckResult) {
        continue;
      } else {
        return false;
      }
    }

    /* Array Check
     *  $all criteria: {a: [1,2,3]}
     *  data: [{a: [1,2,3,4,5], b: 1}] or [{a: [[1,2,3],[1,2,4]]}]
     */
    arrayCheckResult = arrayCheck(data, key, condition);
    if (arrayCheckResult != null) {
      if (arrayCheckResult) {
        continue;
      } else {
        return false;
      }
    }
    if (cmpCheck(data, key, condition)) {
      continue;
    } else {
      return false;
    }
  }
  return true;
};

module.exports = Criteria;
