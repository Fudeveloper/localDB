// Generated by CoffeeScript 1.7.1
'use strict';
var BSON, Utils, eq, toString, _isType;

BSON = require('./bson')();

Utils = {};

toString = Object.prototype.toString;

_isType = function(type) {
  return function(obj) {
    return toString.call(obj).toLowerCase() === ("[object " + type + "]").toLowerCase();
  };
};

Utils.isType = function(ele, type) {
  return _isType(type)(ele);
};

Utils.isObject = _isType("object");

Utils.isString = _isType("string");

Utils.isNumber = _isType("number");

Utils.isArray = _isType("array");

Utils.isFunction = _isType("function");

Utils.isRegex = _isType("regexp");

Utils.isSameType = function(a, b) {
  return toString.call(a) === toString.call(b);
};

Utils.keys = function(obj) {
  var key;
  if (!Utils.isObject(obj)) {
    return [];
  }
  if (Object.keys) {
    return Object.keys(obj);
  }
  return (function() {
    var _results;
    _results = [];
    for (key in obj) {
      if (Utils.has(obj, key)) {
        _results.push(key);
      }
    }
    return _results;
  })();
};

Utils.has = function(obj, key) {
  return obj !== null && obj !== void 0 && Object.prototype.hasOwnProperty.call(obj, key);
};


/*
 *  isEqual function is implemented by underscore and I just rewrite in my project.
 *  https://github.com/jashkenas/underscore/blob/master/underscore.js
 */

eq = function(a, b, aStack, bStack) {
  var aCtor, areArrays, bCtor, className, key, keys, length, result, size;
  if (a === b) {
    return a !== 0 || 1 / a === 1 / b;
  }
  if (a === null && b === void 0) {
    return false;
  }
  if (a === void 0 && b === null) {
    return false;
  }
  className = toString.call(a);
  if (className !== toString.call(b)) {
    return false;
  }
  switch (className) {
    case '[object RegExp]':
      return '' + a === '' + b;
    case '[object String]':
      return '' + a === '' + b;
    case '[object Number]':
      if (+a !== +a) {
        return +b !== +b;
      }
      if (+a === 0) {
        return 1 / +a === 1 / b;
      } else {
        return +a === +b;
      }
    case '[object Date]':
      return +a === +b;
    case '[object Boolean]':
      return +a === +b;
  }
  areArrays = className === '[object Array]';
  if (!areArrays) {
    if (typeof a !== 'object' || typeof b !== 'object') {
      return false;
    }
    aCtor = a.constructor;
    bCtor = b.constructor;
    if ((aCtor !== bCtor) && !(Utils.isFunction(aCtor) && aCtor instanceof aCtor && Utils.isFunction(bCtor) && bCtor instanceof bCtor) && ('constructor' in a && 'constructor' in b)) {
      return false;
    }
  }
  length = aStack.length;
  while (length--) {
    if (aStack[length] === a) {
      return bStack[length] === b;
    }
  }
  aStack.push(a);
  bStack.push(b);
  if (areArrays) {
    size = a.length;
    result = size === b.length;
    if (result) {
      while (size--) {
        if (!(result = eq(a[size], b[size], aStack, bStack))) {
          break;
        }
      }
    }
  } else {
    keys = Utils.keys(a);
    size = keys.length;
    result = Utils.keys(b) === size;
    if (result) {
      while (size--) {
        key = keys[size];
        if (!(result = Utils.has(b, key) && eq(a[key], b[key], aStack, bStack))) {
          break;
        }
      }
    }
  }
  aStack.pop();
  bStack.pop();
  return result;
};

Utils.isEqual = function(a, b) {
  return eq(a, b, [], []);
};

Utils.createObjectId = function() {
  return BSON.ObjectID().inspect();
};

Utils.parse = function(str) {
  if ((str != null) && Utils.isString(str)) {
    return JSON.parse(str);
  } else {
    return [];
  }
};

Utils.stringify = function(obj) {
  if ((obj != null) && (Utils.isArray(obj) || Utils.isObject(obj))) {
    return JSON.stringify(obj);
  } else {
    return "[]";
  }
};

module.exports = Utils;
