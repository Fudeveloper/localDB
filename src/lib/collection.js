// Generated by CoffeeScript 1.7.1
'use strict';
var Collection, Criteria, Utils;

Utils = require('./utils');

Criteria = require('./criteria');

Collection = function(collectionName, db) {
  this.name = "" + db.name + "_" + collectionName;
  this.ls = db.ls;
  this.deserialize();
};

Collection.prototype.deserialize = function() {
  return this.data = Utils.parse(this.ls.getItem(this.name));
};

Collection.prototype.serialize = function() {
  return this.ls.setItem(this.name, Utils.stringify(this.data));
};

Collection.prototype.drop = function() {
  return this.ls.removeItem(this.name);
};

Collection.prototype.insert = function(rowData) {
  this.deserialize();
  this.data.push(rowData);
  return this.serialize();
};

Collection.prototype.update = function(action, options) {
  var actions, criteria, d, key, value, _i, _len, _ref;
  criteria = options.criteria != null ? options.criteria : {};
  this.deserialize();
  _ref = this.data;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    d = _ref[_i];
    if (!(Criteria.check(d, criteria))) {
      continue;
    }
    actions = action.$set;
    for (key in actions) {
      value = actions[key];
      d[key] = value;
    }
  }
  return this.serialize();
};

Collection.prototype.remove = function(options) {
  var criteria, d;
  if (options == null) {
    options = {};
  }
  criteria = options.criteria != null ? options.criteria : {};
  this.deserialize();
  this.data = (function() {
    var _i, _len, _ref, _results;
    _ref = this.data;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      d = _ref[_i];
      if (!Criteria.check(d, criteria)) {
        _results.push(d);
      }
    }
    return _results;
  }).call(this);
  return this.serialize();
};

Collection.prototype.find = function(options) {
  var criteria, d, key, limit, p, pResult, projection, result, value, _i, _j, _len, _len1, _ref;
  if (options == null) {
    options = {};
  }
  criteria = options.criteria != null ? options.criteria : {};
  projection = options.projection != null ? options.projection : {};
  limit = options.limit != null ? options.limit : -1;
  this.deserialize();
  result = [];
  _ref = this.data;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    d = _ref[_i];
    if (!(Criteria.check(d, criteria))) {
      continue;
    }
    if (limit === 0) {
      break;
    }
    limit = limit - 1;
    result.push(d);
  }
  if (JSON.stringify(projection) === "{}") {
    return result;
  }
  pResult = [];
  for (_j = 0, _len1 = result.length; _j < _len1; _j++) {
    d = result[_j];
    p = {};
    for (key in projection) {
      value = projection[key];
      if (value === 1) {
        p[key] = d[key];
      }
    }
    pResult.push(p);
  }
  return pResult;
};

Collection.prototype.findOne = function(options) {
  if (options == null) {
    options = {};
  }
  options.limit = 1;
  return this.find(options);
};

module.exports = Collection;
