// Generated by CoffeeScript 1.8.0
define(function(require, exports, module) {
  "use strict";
  var Encrypt, Storage, Support, Utils;
  Utils = require("lib/utils");
  Support = require("lib/support");
  Encrypt = require("lib/encrypt");
  Storage = (function() {
    function Storage(expire, encrypt, token) {
      this.expire = expire;
      this.encrypt = encrypt;
      this.token = token;
      if (this.expire === "window") {
        if (!Support.sessionstorage()) {
          throw new Error("sessionStorage is not supported!");
        }
        this.storage = sessionStorage;
      } else if (this.expire === "none") {
        if (!Support.localstorage()) {
          throw new Error("localStorage is not supported!");
        }
        this.storage = localStorage;
      }
    }

    Storage.prototype.key = function(index, callback) {
      var e, key;
      try {
        key = this.storage.key(index);
      } catch (_error) {
        e = _error;
        callback(-1, e);
      }
      callback(key);
    };

    Storage.prototype.size = function(callback) {
      var e, size;
      try {
        size = this.storage.length;
      } catch (_error) {
        e = _error;
        callback(-1, e);
      }
      callback(size);
    };

    Storage.prototype.setItem = function(key, val, callback) {
      var data, e, flag, self;
      self = this;
      try {
        if (this.encrypt) {
          val = Encrypt.encode(val, this.token);
        }
        this.storage.setItem(key, val);
      } catch (_error) {
        e = _error;

        /* TODO
         *  需要在LocalDB的构造函数中增加配置参数，来确定是否自动删除最老数据
         *  增加过期时间配置项
         */

        /* TODO
         *  这里有可能是非容量满等其他原因导致出错
         *  所以需要设置一个最大尝试阀值，或者根据出错信息来判断是否继续循环
         *  避免死循环
         */
        flag = true;
        if (this.encrypt) {
          val = Encrypt.decode(val, this.token);
        }
        data = Utils.parse(val);
        while (flag) {
          try {
            data.splice(0, 1);
            val = Utils.stringify(data);
            if (self.encrypt) {
              val = Encrypt.encode(val, self.token);
            }
            self.storage.setItem(key, val);
            flag = false;
          } catch (_error) {}
        }
      }

      /* TODO
       *  目前采用的是删除初始数据来保证在数据存满以后仍然可以继续存下去
       *  在初始化LocalDB的时候需要增加配置参数，根据参数来决定是否自动删除初始数据，还是返回e
       */
      callback();
    };

    Storage.prototype.getItem = function(key, callback) {
      var e, item;
      try {
        item = this.storage.getItem(key);
        if (this.encrypt) {
          item = Encrypt.decode(item, this.token);
        }
      } catch (_error) {
        e = _error;
        callback(null, e);
      }
      callback(item);
    };

    Storage.prototype.removeItem = function(key, callback) {
      var e;
      try {
        this.storage.removeItem(key);
      } catch (_error) {
        e = _error;
        callback(e);
      }
      callback();
    };

    Storage.prototype.usage = function(callback) {

      /*
       *  check it out: http://stackoverflow.com/questions/4391575/how-to-find-the-size-of-localstorage
       */
      var allStrings, e, key, val, _ref;
      try {
        allStrings = "";
        _ref = this.storage;
        for (key in _ref) {
          val = _ref[key];
          allStrings += val;
        }
      } catch (_error) {
        e = _error;
        callback(-1, e);
      }
      return callback(allStrings.length / 512);
    };

    return Storage;

  })();
  return module.exports = Storage;
});
