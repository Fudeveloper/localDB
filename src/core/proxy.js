// Generated by CoffeeScript 1.8.0
define(function(require, exports, module) {
  "use strict";
  var Evemit, Proxy, Utils;
  Evemit = require("lib/evemit");
  Utils = require("core/utils");
  Proxy = (function() {
    function Proxy(options) {
      var self;
      self = this;
      this.expire = options.expire;
      this.encrypt = options.encrypt;
      this.name = options.name;
      this.proxy = options.proxy;
      this.insert_guarantee = options.insert_guarantee;
      this.evemit = new Evemit();
      this.iframe = Utils.createIframe(this.proxy);
      Evemit.bind(window, "message", function(e) {
        var result;
        result = JSON.parse(e.data);
        if (self.proxy.indexOf(e.origin) === -1) {
          return;
        }
        if (result.data != null) {
          return self.evemit.emit(result.eve, result.data, result.err);
        } else {
          return self.evemit.emit(result.eve, result.err);
        }
      });
    }

    Proxy.prototype.sendMessage = function(type, data, callback) {
      var e, eve, ifrWin, self;
      self = this;
      eve = type + "|" + new Date().getTime();
      data.eve = eve;
      data.expire = this.expire;
      data.encrypt = this.encrypt;
      data.name = this.name;
      data.insert_guarantee = this.insert_guarantee;
      this.evemit.once(eve, callback);
      data = JSON.stringify(data);
      ifrWin = this.iframe.contentWindow;

      /*
       *  当加载非同源iframe时，不能简单的通过 iframe.contentWindow.document.readystate来判断页面是否为complete
       *  第一: readystate为complete不代表server端的localDB初始化完成
       *  第二: 一旦非同源iframe加载完成，则无法访问到readystate
       *  因此通过能否访问到iframe.contentWindow.document来判断其是否完成加载
          *   如果能访问到，则给iframe的load事件增加函数
          *   如果不能访问到，则直接iframe.contentWindow.postMessage发送请求
       */
      try {
        ifrWin.document;
        return Evemit.bind(this.iframe, "load", function() {
          return ifrWin.postMessage(data, Utils.getOrigin(self.proxy));
        });
      } catch (_error) {
        e = _error;
        return ifrWin.postMessage(data, Utils.getOrigin(this.proxy));
      }
    };

    Proxy.prototype.key = function(index, callback) {
      return this.sendMessage("key", {
        index: index
      }, callback);
    };

    Proxy.prototype.size = function(callback) {
      return this.sendMessage("size", {}, callback);
    };

    Proxy.prototype.setItem = function(key, val, callback) {
      return this.sendMessage("setItem", {
        key: key,
        val: val
      }, callback);
    };

    Proxy.prototype.getItem = function(key, callback) {
      return this.sendMessage("getItem", {
        key: key
      }, callback);
    };

    Proxy.prototype.removeItem = function(key, callback) {
      return this.sendMessage("removeItem", {
        key: key
      }, callback);
    };

    Proxy.prototype.usage = function(callback) {
      return this.sendMessage("usage", {}, callback);
    };

    return Proxy;

  })();
  return module.exports = Proxy;
});
